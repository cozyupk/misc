using System;
using System.Linq;
using System.Text;

namespace PartialClassExtGen.GenalyzerBase
{
	/// <summary>
	/// Provides a base class for generating partial class implementations using a specified attribute type.
	/// </summary>
	/// <remarks>This abstract class serves as a foundation for implementing partial class generators. It
	/// integrates with the <see cref="IIncrementalGenerator"/> and <see cref="IPartialClassExtender"/> interfaces to
	/// facilitate incremental source generation and partial class extension. Derived classes must implement the <see
	/// cref="GenerateImplementations"/> method to define the specific logic for generating code based on the provided
	/// symbols.</remarks>
	/// <typeparam name="TAttribute">The type of attribute that identifies the target classes for partial class generation. Must derive from <see
	/// cref="Attribute"/>.</typeparam>
	partial class VanillaPCEG<TAttribute, TPartialClassExtender, TDiagnostics, TTargetClassMeta>
    {
		/// <summary>
		/// Gets the name of the extension that this implementation generates.
		/// </summary>
		public virtual string ExtensionName
		{
			get
			{
				if (string.IsNullOrWhiteSpace(AutoGeneratedExtensionName))
				{
					throw new InvalidOperationException(
						$"Couldn't Auto-generate ExtensionName property. " +
						"You can override ExtensionName property as you like."
					);
				}
				return AutoGeneratedExtensionName!;
			}
		}

		/// <summary>
		/// Gets the suffix used for naming generated files.
		/// </summary>
		public virtual string SuffixForGeneratedFiles
		{
			get
			{
				if (string.IsNullOrWhiteSpace(AutoGeneratedSuffixForGeneratedFiles))
				{
					throw new InvalidOperationException(
						$"Couldn't Auto-generate SuffixForGeneratedFiles property. " +
						"You can override SuffixForGeneratedFiles property as you like."
					);
				}
				return AutoGeneratedSuffixForGeneratedFiles!;
			}
		}

		/// <summary>
		/// Gets the prefix used for diagnostic IDs.
		/// </summary>
		public virtual string PrefixForDiagnosticId
		{
			get
			{
				if (string.IsNullOrWhiteSpace(AutoGeneratedPrefixForDiagnosticId))
				{
					throw new InvalidOperationException(
						$"Couldn't Auto-generate PrefixForDiagnosticId property. " +
						"You can override AutoGeneratedPrefixForDiagnosticId property as you like."
					);
				}
				return AutoGeneratedPrefixForDiagnosticId!;
			}
		}

		/// <summary>
		/// Gets the prefix used for diagnostic error IDs.
		/// </summary>
		public virtual string ErrorPrefixForDiagnosticId
									=> PrefixForDiagnosticId;

        /// <summary>
        /// Gets the prefix used for diagnostic warning IDs.
        /// </summary>
        public virtual string WarningPrefixForDiagnosticId
									=> $"{PrefixForDiagnosticId}W";

        /// <summary>
        /// Gets or sets the auto-generated extension name derived from the attribute type.
        /// </summary>
        protected internal static string? AutoGeneratedExtensionName
		{ private get; set; } = ConvertToSpacedName(typeof(TAttribute).Name);

		/// <summary>
		/// Gets or sets the suffix used to identify auto-generated files.
		/// </summary>
		protected internal static string? AutoGeneratedSuffixForGeneratedFiles
		{ private get; set; } = Abbreviate(typeof(TAttribute).Name);

		/// <summary>
		/// Gets or sets the prefix automatically generated for diagnostic IDs based on the attribute type name.
		/// </summary>
		protected internal static string? AutoGeneratedPrefixForDiagnosticId
		{ private get; set; } = ConvertToAcronym(typeof(TAttribute).Name);

		/// <summary>
		/// Converts a PascalCase string to a spaced name and removes the trailing "Attribute" suffix, if present.
		/// </summary>
		/// <remarks>This method is commonly used to transform class or type names into a more
		/// human-readable format.  For example, "FluentBuilderAttribute" is converted to "Fluent Builder".</remarks>
		/// <param name="name">The PascalCase string to convert. Must not be null.</param>
		/// <returns>A string with spaces inserted between words, or <see langword="null"/> if the resulting string is empty or
		/// consists only of whitespace.</returns>
		protected internal static string? ConvertToSpacedName(string name)
		{
			// Remove trailing "Attribute" and convert a PascalCase name to a spaced name.
			// ex. "FluentBuilderAttribute" into "Fluent Builder"
			const string suffix = "Attribute";
			if (name.EndsWith(suffix))
				name = name.Substring(0, name.Length - suffix.Length);
			var sb = new StringBuilder();
			for (int i = 0; i < name.Length; i++)
			{
				if (i > 0 && char.IsUpper(name[i]) && !char.IsUpper(name[i - 1]))
				{
					sb.Append(' ');
				}
				sb.Append(name[i]);
			}

			// Check the result is appropriate
			var result = sb.ToString().Trim();

			if (string.IsNullOrWhiteSpace(result))
			{
				return null; // Return null if the result is empty or whitespace
			}

			return result;
		}

		/// <summary>
		/// Generates an abbreviated version of the specified name by extracting the first capital letter          of
		/// each word in PascalCase and appending "Gen" to the result.
		/// </summary>
		/// <param name="name">The input string to abbreviate. Must be in PascalCase format.</param>
		/// <returns>A string containing the abbreviated name with a maximum length of 6 characters, followed by "Gen".         
		/// Returns <see langword="null"/> if the input results in an empty or whitespace abbreviation.</returns>
		protected internal static string? Abbreviate(string name)
		{
			// Take only first capital letter of each word in PascalCase
			var sb = new StringBuilder();
			for (int i = 0; i < name.Length; i++)
			{
				if (i == 0 || (char.IsUpper(name[i]) && !char.IsUpper(name[i - 1])))
				{
					sb.Append(name[i]);
				}
			}

			// If the result is longer than 6 characters, truncate it to 6 characters.
			var result = sb.ToString().Trim();
			if (6 < result.Length)
			{
				result = result.Substring(0, 6);
			}

			// Check the result is appropriate
			if (string.IsNullOrWhiteSpace(result))
			{
				return null; // Return null if the result is empty or whitespace
			}

			result += "Gen";
			return result;
		}

		/// <summary>
		/// Converts the specified name into an acronym by removing vowels and non-uppercase letters.
		/// </summary>
		/// <remarks>The method processes the input string by removing all vowels and non-uppercase
		/// letters, converting the remaining characters to uppercase. If the resulting string is empty or contains only
		/// whitespace, the method returns <see langword="null"/>.</remarks>
		/// <param name="name">The input string to convert into an acronym. Must not be null.</param>
		/// <returns>A string representing the acronym derived from the input name, or <see langword="null"/> if the resulting
		/// acronym is empty or consists only of whitespace.</returns>
		protected internal static string? ConvertToAcronym(string name)
		{
            // Remove trailing "Attribute" and convert a PascalCase name to a spaced name.
            // ex. "FluentBuilderAttribute" into "Fluent Builder"
            const string suffix = "Attribute";
            if (name.EndsWith(suffix))
                name = name.Substring(0, name.Length - suffix.Length);

            // remove vowels and non-uppercase
            var result = new string(name
				.Where(char.IsLetter)
				.Where(c => !"aeiou".Contains(char.ToLowerInvariant(c)))
				.Select(char.ToUpperInvariant)
				.ToArray()).Trim();

			// Check the result is appropriate
			if (string.IsNullOrWhiteSpace(result))
			{
				return null; // Return null if the result is empty or whitespace
			}

			return result;
		}
	}
}
