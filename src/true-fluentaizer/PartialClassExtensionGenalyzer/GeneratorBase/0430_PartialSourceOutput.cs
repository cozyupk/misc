using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using PartialClassExtGen.Abstractions.Common;
using PartialClassExtGen.Abstractions.Generator;
using PartialClassExtGen.Utils;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace PartialClassExtGen.GeneratorBase
{
    /// <summary>
    /// Represents a source output generator that processes partial classes and generates additional source code using a
    /// specified extender of type <typeparamref name="TPartialClassExtender"/>.
    /// </summary>
    /// <remarks>This class is designed to work with the source generation infrastructure in .NET,
    /// specifically for scenarios where partial classes need to be extended with additional functionality or generated
    /// code. It uses the specified <typeparamref name="TPartialClassExtender"/> to perform the code generation
    /// logic.</remarks>
    /// <typeparam name="TPartialClassExtender">The type of the extender that provides additional functionality for handling partial classes. Must implement
    /// <see cref="IPartialClassExtender"/> and have a parameterless constructor.</typeparam>
    public sealed class PartialSourceOutput<TPartialClassExtender>
        : PartialClassExtendeeBase<TPartialClassExtender>, ISourceOutput
        where TPartialClassExtender : IPartialClassExtender, new()
    {
        public void SourceOutput(SourceProductionContext spc, (Compilation Left, ImmutableArray<ITargetClassMeta?> Right) source)
        {
            // Get the compilation and the list of target classes
            var (compilation, targetClasses) = source;

            // Create an instance of the extender
            var extender = new TPartialClassExtender();

            // Output the source code for each target class with try-catch for exception handling
            // For each target class, generate the extension codes
            foreach (var targetClass in targetClasses)
            {
                if (targetClass == null || targetClass.Symbol is not INamedTypeSymbol symbol)
                    continue;

                try
                {
                    SourceOutputInternal(
                        spc, compilation, symbol,
                        extender
                    );
                }
                catch (Exception ex)
                {
                    // If an exception occurs during the source output, report it
                    spc.ReportDiagnostic(Diagnostic.Create(
                        PCEGDiagnosticDescriptors<TPartialClassExtender>
                            .PCEG0004_UnexpectedExceptionWhileGeneratingCode(ex, extender),
                        Location.None
                    ));
                }
            }
        }

        /// <summary>
        /// Generates source code for a partial class using the specified extender and reports any diagnostics or errors
        /// encountered during the process.
        /// </summary>
        /// <remarks>This method uses the provided <paramref name="extender"/> to generate source code for
        /// the specified <paramref name="symbol"/>. If the extender generates diagnostics, they are reported through
        /// the <paramref name="spc"/> context. If any diagnostic has a severity of <see
        /// cref="DiagnosticSeverity.Error"/>, the method stops processing the current class.  If an exception occurs
        /// during the generation process, a diagnostic is reported for each location of the class, and the method skips
        /// further processing for the current class.</remarks>
        /// <param name="spc">The context used to add generated source code and report diagnostics.</param>
        /// <param name="compilation"> The compilation context that provides access to the compilation being processed.</param>
        /// <param name="symbol">The symbol representing the partial class to be extended.</param>
        /// <param name="extender">The extender responsible for generating the implementations for the partial class.</param>
        private void SourceOutputInternal(
                SourceProductionContext spc, Compilation compilation,
                INamedTypeSymbol symbol, IPartialClassExtender extender
        )
        {
            // Generate the source code for the class
            var sb = new StringBuilder();
            sb.AppendLine($"// This file is auto-generated by {extender.GetType().FullName}");

            // Generate the extended class
            IEnumerable<Diagnostic>? diagnostics;
            try
            {
                // Generate the implementations using the extender
                diagnostics = extender.GenerateImplementations(symbol, compilation, sb);
            }
            catch (Exception ex)
            {
                // If an exception occurs during code generation, report it for each location of the class
                foreach (var loc in symbol.Locations)
                {
                    // Report the diagnostic for the exception
                    spc.ReportDiagnostic(Diagnostic.Create(
                        PCEGDiagnosticDescriptors<TPartialClassExtender>
                            .PCEG0003_GenerateImplementations_ThrewException(symbol, ex, extender),
                        loc
                    ));
                }
                return; // Skip to the next class if an exception was thrown
            }

            if (diagnostics is not null)
            {
                bool isError = false;
                foreach (var d in diagnostics)
                {
                    // Report each diagnostic generated by the extender
                    spc.ReportDiagnostic(d);
                    if (d.Severity == DiagnosticSeverity.Error)
                    {
                        isError = true; // If any diagnostic is an error, set the flag
                    }
                }
                if (isError)
                    return; // Skip to the next class if any diagnostic is an error
            }

            // Output the generated source code
            spc.AddSource(
                $"{symbol.ToSafeFileName()}-{Extender.SuffixForGeneratedFiles}.g.cs",
                SourceText.From(sb.ToString(), Encoding.UTF8)
            );
        }
    }
}
