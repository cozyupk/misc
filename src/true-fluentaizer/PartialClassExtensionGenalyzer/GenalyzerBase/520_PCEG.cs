using Microsoft.CodeAnalysis;
using PartialClassExtGen.Abstractions.Common;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace PartialClassExtGen.GenalyzerBase
{
    /// <summary>
    /// Provides a base class for extending partial classes with functionality based on a specific attribute type
    /// in type safety manner.
    /// </summary>
    /// <remarks>This abstract class serves as a foundation for implementing partial class extenders that
    /// generate code or diagnostics based on the presence of a specific attribute. It provides utility methods and
    /// properties for generating names, suffixes, and prefixes related to the target attribute.
    /// This class is intended to be used as a base class and should not be instantiated directly.</remarks>
    /// <typeparam name="TAttribute">The type of the attribute that this extender targets. Must derive from <see cref="Attribute"/>.</typeparam>
    public abstract class PCEG<TAttribute> : IPartialClassExtender
        where TAttribute : Attribute
    {
        /// <summary>
        /// Gets the type of the target attribute associated with this instance.
        /// </summary>
        public Type TargetAttribute { get; } = typeof(TAttribute);

        /// <summary>
        /// Gets or sets the auto-generated extension name derived from the attribute type.
        /// </summary>
        protected internal static string? AutoGeneratedExtensionName
            { private get; set; } = ConvertToSpacedName(typeof(TAttribute).Name);

        /// <summary>
        /// Gets or sets the suffix used to identify auto-generated files.
        /// </summary>
        protected internal static string? AutoGeneratedSuffixForGeneratedFiles
            { private get; set; } = Abbreviate(typeof(TAttribute).Name);

        /// <summary>
        /// Gets or sets the prefix automatically generated for diagnostic IDs based on the attribute type name.
        /// </summary>
        protected internal static string? AutoGeneratedPrefixForDiagnosticId
            { private get; set; } = ConvertToAcronym(typeof(TAttribute).Name);

        /// <summary>
        /// Gets the name of the extension that this implementation generates.
        /// </summary>
        public virtual string ExtensionName
        {
            get
            {
                if (string.IsNullOrWhiteSpace(AutoGeneratedExtensionName))
                {
                    throw new InvalidOperationException(
                        $"Couldn't Auto-generate ExtensionName property. " +
                        "You can override ExtensionName property as you like."
                    );
                }
                return AutoGeneratedExtensionName!;
            }
        }

        /// <summary>
        /// Gets the suffix used for naming generated files.
        /// </summary>
        public virtual string SuffixForGeneratedFiles
        {
            get
            {
                if (string.IsNullOrWhiteSpace(AutoGeneratedSuffixForGeneratedFiles))
                {
                    throw new InvalidOperationException(
                        $"Couldn't Auto-generate SuffixForGeneratedFiles property. " +
                        "You can override SuffixForGeneratedFiles property as you like."
                    );
                }
                return AutoGeneratedSuffixForGeneratedFiles!;
            }
        }

        /// <summary>
        /// Gets the prefix used for diagnostic IDs.
        /// </summary>
        public virtual string PrefixForDiagnosticId
        {
            get
            {
                if (string.IsNullOrWhiteSpace(AutoGeneratedPrefixForDiagnosticId))
                {
                    throw new InvalidOperationException(
                        $"Couldn't Auto-generate PrefixForDiagnosticId property. " +
                        "You can override AutoGeneratedPrefixForDiagnosticId property as you like."
                    );
                }
                return AutoGeneratedPrefixForDiagnosticId!;
            }
        }

        /// <summary>
        /// Converts a PascalCase string to a spaced name and removes the trailing "Attribute" suffix, if present.
        /// </summary>
        /// <remarks>This method is commonly used to transform class or type names into a more
        /// human-readable format.  For example, "FluentBuilderAttribute" is converted to "Fluent Builder".</remarks>
        /// <param name="name">The PascalCase string to convert. Must not be null.</param>
        /// <returns>A string with spaces inserted between words, or <see langword="null"/> if the resulting string is empty or
        /// consists only of whitespace.</returns>
        protected internal static string? ConvertToSpacedName(string name)
        {
            // Remove trailing "Attribute" and convert a PascalCase name to a spaced name.
            // ex. "FluentBuilderAttribute" into "Fluent Builder"
            const string suffix = "Attribute";
            if (name.EndsWith(suffix))
                name = name.Substring(0, name.Length - suffix.Length);
            var sb = new StringBuilder();
            for (int i = 0; i < name.Length; i++)
            {
                if (i > 0 && char.IsUpper(name[i]) && !char.IsUpper(name[i - 1]))
                {
                    sb.Append(' ');
                }
                sb.Append(name[i]);
            }

            // Check the result is appropriate
            var result = sb.ToString().Trim();

            if (string.IsNullOrWhiteSpace(result))
            {
                return null; // Return null if the result is empty or whitespace
            }

            return result;
        }

        /// <summary>
        /// Generates an abbreviated version of the specified name by extracting the first capital letter          of
        /// each word in PascalCase and appending "Gen" to the result.
        /// </summary>
        /// <param name="name">The input string to abbreviate. Must be in PascalCase format.</param>
        /// <returns>A string containing the abbreviated name with a maximum length of 6 characters, followed by "Gen".         
        /// Returns <see langword="null"/> if the input results in an empty or whitespace abbreviation.</returns>
        protected internal static string? Abbreviate(string name)
        {
            // Take only first capital letter of each word in PascalCase
            var sb = new StringBuilder();
            for (int i = 0; i < name.Length; i++)
            {
                if (i == 0 || (char.IsUpper(name[i]) && !char.IsUpper(name[i - 1])))
                {
                    sb.Append(name[i]);
                }
            }

            // If the result is longer than 6 characters, truncate it to 6 characters.
            var result = sb.ToString().Trim();
            if (6 < result.Length)
            {
                result = result.Substring(0, 6);
            }

            // Check the result is appropriate
            if (string.IsNullOrWhiteSpace(result))
            {
                return null; // Return null if the result is empty or whitespace
            }

            result += "Gen";
            return result;
        }

        /// <summary>
        /// Converts the specified name into an acronym by removing vowels and non-uppercase letters.
        /// </summary>
        /// <remarks>The method processes the input string by removing all vowels and non-uppercase
        /// letters, converting the remaining characters to uppercase. If the resulting string is empty or contains only
        /// whitespace, the method returns <see langword="null"/>.</remarks>
        /// <param name="name">The input string to convert into an acronym. Must not be null.</param>
        /// <returns>A string representing the acronym derived from the input name, or <see langword="null"/> if the resulting
        /// acronym is empty or consists only of whitespace.</returns>
        protected internal static string? ConvertToAcronym(string name)
        {
            // remove vowels and non-uppercase
            var result = new string(name
                .Where(char.IsLetter)
                .Where(c => !"aeiou".Contains(char.ToLowerInvariant(c)))
                .Select(char.ToUpperInvariant)
                .ToArray()).Trim();

            // Check the result is appropriate
            if (string.IsNullOrWhiteSpace(result))
            {
                return null; // Return null if the result is empty or whitespace
            }

            return result;
        }

        /// <summary>
        /// Generates implementations for the specified symbol and appends the generated code to the provided <see
        /// cref="StringBuilder"/>.
        /// </summary>
        /// <remarks>This method is abstract and must be implemented by a derived class. It is intended to
        /// generate code based on the provided symbol and append the generated code to the specified <see
        /// cref="StringBuilder"/>. The method may also produce diagnostics to indicate errors or warnings encountered
        /// during the generation process.</remarks>
        /// <param name="symbol">The symbol representing the type for which implementations are to be generated. Must not be <see
        /// langword="null"/>.</param>
        /// <param name="compilation">The current compilation context. Provides semantic and syntactic information required for code generation.
        /// Must not be <see langword="null"/>.</param>
        /// <param name="sb">The <see cref="StringBuilder"/> to which the generated code will be appended. Must not be <see
        /// langword="null"/>.</param>
        /// <returns>A collection of <see cref="Diagnostic"/> objects representing any issues encountered during code generation,
        /// or <see langword="null"/> if no diagnostics are produced.</returns>
        public abstract IEnumerable<Diagnostic>? GenerateImplementations(INamedTypeSymbol symbol, Compilation compilation, StringBuilder sb);
    }
}
