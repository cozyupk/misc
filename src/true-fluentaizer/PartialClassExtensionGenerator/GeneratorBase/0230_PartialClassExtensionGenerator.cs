using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using PartialClassExtensionGenerator.Abstractions;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace PartialClassExtensionGenerator.GeneratorBase
{
    public class PartialClassExtensionGenerator<TPartialClassExtender> : IIncrementalGenerator
        where TPartialClassExtender : IPartialClassExtender, new()
    {
        private static IPartialClassExtender Extender { get; } = new TPartialClassExtender();
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // Identify all target classes
            var goingToBeExtendedClasses = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (s, _) => s is ClassDeclarationSyntax cds && cds.AttributeLists.Count > 0,
                    transform: static (ctx, _) => GetExtensionTarget(ctx)
                );
                // .Where(static m => m is not null);

            // Combine with compilation (optional here)
            var compilationAndClasses = context.CompilationProvider.Combine(goingToBeExtendedClasses.Collect());

            // Register the source output for the identified classes
            context.RegisterSourceOutput(
                compilationAndClasses, (spc, source) =>
                {
                    // If there are any exceptions, report them
                    var diagnostics = source.Right
                        .Where(x => x is not null && x.SyntaxProvidingDiagnostics is not null)
                        .SelectMany(x => x?.SyntaxProvidingDiagnostics)
                        .ToImmutableArray();
                    if (0 < diagnostics.Length)
                    {
                        var isError = false;
                        foreach (var diagnostic in diagnostics)
                        {
                            if (diagnostic is null)
                                continue; // Skip if the diagnostic is null
                            // Report any exceptions that occurred during the processing
                            spc.ReportDiagnostic(diagnostic);
                            if (diagnostic.Severity == DiagnosticSeverity.Error)
                            {
                                isError = true; // If any diagnostic is an error, set the flag
                            }
                        }
                        if (isError)
                            return; // Exit if any diagnostic is an error
                    }

                    // Get the compilation and the list of target classes
                    var (compilation, targetClasses) = source;

                    // Create an instance of the extender
                    var extender = new TPartialClassExtender();

                    // Output the source code for each target class with try-catch for exception handling
                    // For each target class, generate the extension codes
                    foreach (var targetClass in targetClasses)
                    {
                        if (targetClass == null || targetClass.Symbol is not INamedTypeSymbol symbol || !targetClass.IsMatchedCriteria)
                            continue;

                        try
                        {
                            SourceOutput(
                                spc, compilation, symbol,
                                extender
                            );
                        }
                        catch (Exception ex)
                        {
                            // If an exception occurs during the source output, report it
                            spc.ReportDiagnostic(Diagnostic.Create(
                                PartialClassExtensionGeneratorDiagnosticDescriptors<TPartialClassExtender>
                                    .EXGEN0004_UnexpectedExceptionWhileGeneratingCode(ex, extender),
                                Location.None
                            ));
                        }
                    }
                }
            );
        }

        static void SourceOutput(
            SourceProductionContext spc, Compilation _,
            INamedTypeSymbol symbol, IPartialClassExtender extender
        )
        {
            // Generate the source code for the class
            var sb = new StringBuilder();
            sb.AppendLine($"// This file is auto-generated by {extender.GetType().FullName}");

            // Generate the extended class
            IEnumerable<Diagnostic>? diagnostics;
            try
            {
                // Generate the implementations using the extender
                diagnostics = extender.GenerateImplementations(symbol, sb);
            }
            catch (Exception ex)
            {
                // If an exception occurs during code generation, report it for each location of the class
                foreach (var loc in symbol.Locations)
                {
                    // Report the diagnostic for the exception
                    spc.ReportDiagnostic(Diagnostic.Create(
                        PartialClassExtensionGeneratorDiagnosticDescriptors<TPartialClassExtender>
                            .EXGEN0003_GenerateImplementations_ThrewException(symbol, ex, extender),
                        loc
                    ));
                }
                return; // Skip to the next class if an exception was thrown
            }

            if (diagnostics is not null)
            {
                bool isError = false;
                foreach (var d in diagnostics)
                {
                    // Report each diagnostic generated by the extender
                    spc.ReportDiagnostic(d);
                    if (d.Severity == DiagnosticSeverity.Error)
                    {
                        isError = true; // If any diagnostic is an error, set the flag
                    }
                }
                if (isError)
                    return; // Skip to the next class if any diagnostic is an error
            }

            // Output the generated source code
            spc.AddSource($"{symbol.ToSafeFileName()}-{Extender.GeneratedFileSuffix}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
        }

        private static BuilderClassInfo? GetExtensionTarget(
            GeneratorSyntaxContext context
        ) {
            // Ensure the node is a class declaration
            var classDecl = (ClassDeclarationSyntax)context.Node;
            if (context.SemanticModel.GetDeclaredSymbol(classDecl) is not INamedTypeSymbol symbol)
                return null;

            // Prepare variables to store the results
            bool isMatchedCriteria = false;
            var diagnostics = new List<Diagnostic>();

            // Return BuilderClassInfo if the class matches the extender's target criteria
            try
            {
                // Check if the class is partial
                var checkResult = Extender.IsTargetClass(symbol);
                if (checkResult.Item2 is not null)
                {
                    // If the extender returned a diagnostic, add it to the diagnostics list
                    diagnostics.Add(checkResult.Item2);
                }

                // If the class matches the extender's criteria
                if (checkResult.Item1)
                {
                    isMatchedCriteria = true;
                    if (!classDecl.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword)))
                    {
                        var d = Diagnostic.Create(
                                    PartialClassExtensionGeneratorDiagnosticDescriptors<TPartialClassExtender>
                                    .EXGEN0001_Missing_Partial_Modifier(symbol),
                                classDecl.GetLocation()
                        );
                        diagnostics.Add(d);
                    }
                }
            } catch (Exception ex)
            {
                // If an exception occurs, just queue it for later reporting
                var d = Diagnostic.Create(
                            PartialClassExtensionGeneratorDiagnosticDescriptors<TPartialClassExtender>
                                .EXGEN0002_IsTargetClass_ThrewException(symbol, ex, Extender),
                            classDecl.GetLocation()
                );
                diagnostics.Add(d);
            }

            // If class does not match the criteria, return null
            return new BuilderClassInfo(isMatchedCriteria, symbol, diagnostics);
        }

        /// <summary>
        /// Represents information about a builder class, including its associated symbol and any diagnostic
        /// information.
        /// </summary>
        /// <remarks>This class encapsulates metadata about a builder class, such as its symbol
        /// representation in the source code and any diagnostic information that may be relevant during syntax
        /// analysis. It is designed to be immutable and is used to convey information about builder classes in a
        /// structured manner.</remarks>
        private sealed class BuilderClassInfo
        {
            /// <summary>
            /// Gets a value indicating whether the current object meets the specified criteria.
            /// </summary>
            public bool IsMatchedCriteria { get; }

            /// <summary>
            /// Gets the symbol representing the named type in the source code.
            /// </summary>
            public INamedTypeSymbol Symbol { get; }

            /// <summary>
            /// Gets the diagnostic information associated with syntax analysis, if available.
            /// </summary>
            public IEnumerable<Diagnostic>? SyntaxProvidingDiagnostics { get; }

            /// <summary>
            /// Represents information about a builder class, including its associated symbol and any diagnostic
            /// information.
            /// </summary>
            /// <param name="symbol">The symbol representing the builder class. This parameter cannot be null.</param>
            /// <param name="diagnostic">An optional diagnostic associated with the builder class. Can be null if no diagnostic is provided.</param>
            public BuilderClassInfo(bool isMatchedCriteria, INamedTypeSymbol symbol, IEnumerable<Diagnostic>? diagnostic = null)
            {
                // Store the parameters, with validation if necessary.
                IsMatchedCriteria = isMatchedCriteria;
                Symbol = symbol ?? throw new ArgumentNullException(nameof(symbol));
                SyntaxProvidingDiagnostics = diagnostic;
            }
        }
    }
}