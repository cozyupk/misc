
using Probe;

namespace ConsoleApp1_en_US
{
    /// <summary>
    /// Observe the behavior of ContinueWith and ConfigureAwait
    /// </summary>
    internal class Program
    {
        /// <summary>
        /// Entry point of the application. (comment auto-generated by GPT)
        /// </summary>
        static async Task Main(string[] _1)
        {
            // Start the "thread stirring" process
            CancellationTokenSource cts = new();
            _ = ThreadProbe.StirThreadPoolAsync(cts.Token);
            _ = ThreadProbe.StirThreadPoolAsync(cts.Token);
            _ = ThreadProbe.StirThreadPoolAsync(cts.Token);

            Console.WriteLine();

            // Execute assuming SynchronizationContext.Current is null
            if (SynchronizationContext.Current != null)
            {
                throw new InvalidOperationException(
                    "This program is designed to run in a context where SynchronizationContext.Current is null. " +
                    "Please ensure you are running it in a console application or similar environment.");
            }

            // Create an instance to observe thread state
            var threadProbe = new ThreadProbe();

            // Execute cases to observe behavior of ContinueWith and ConfigureAwait
            Console.WriteLine("=== When SynchronizationContext.Current is null ===");
            await ExecuteCase(threadProbe, Case_AwaitAndReturnOriginalTask(threadProbe));
            await ExecuteCase(threadProbe, Case_AwaitAndReturnContinueWithTask(threadProbe));
            await ExecuteCase(threadProbe, Case_AwaitAndReturnContinueWithUnwrappedTask(threadProbe));

            // Execute in a single-threaded context (e.g. UI thread or ASP.NET)
            var syncCtx = new SingleThreadSyncContext();
            SynchronizationContext.SetSynchronizationContext(syncCtx);

            // Switch to the single-threaded context
            await Task.Yield();

            Console.WriteLine($"=== When SynchronizationContext.Current is single-threaded (no ConfigureAwait) ===");
            await ExecuteCase(threadProbe, Case_AwaitAndReturnContinueWithUnwrappedTask(threadProbe));

            var patterns = new List<(bool configureAwaitForExecuting, bool configureAwaitForWaiting)>
            {
                (false, false), (false, true), (true, false), (true, true)
            };
            foreach (var (configureAwaitForExecuting, configureAwaitForWaiting) in patterns)
            {
                Console.WriteLine($"=== When SynchronizationContext.Current is single-threaded (ConfigureAwait: {configureAwaitForExecuting}/{configureAwaitForWaiting}) ===");
                await ExecuteCaseWithConfigureAwait(
                    threadProbe, Case_AwaitAndReturnContinueWithUnwrappedTask(threadProbe), configureAwaitForExecuting, configureAwaitForWaiting
                );
            }

            Console.WriteLine($"=== When SynchronizationContext.Current is single-threaded (await Task.CompletedTask.ConfigureAwait(false);) ===");
            await ExecuteCaseWithEmptyAwait(
                threadProbe, Case_AwaitAndReturnContinueWithUnwrappedTask(threadProbe)
            );

            Console.WriteLine($"=== When SynchronizationContext.Current is single-threaded (YieldOnlyAsync) ===");
            await ExecuteCaseWithEmptyAwait2(
                threadProbe, Case_AwaitAndReturnContinueWithUnwrappedTask(threadProbe)
            );

            SynchronizationContext.SetSynchronizationContext(null); // Reset SynchronizationContext to null
            syncCtx.Complete(); // Mark the context as complete

            // Stop the "thread stirring" process
            cts.Cancel();
            await Task.Delay(100); // Wait a bit
        }

        static async Task ExecuteCase(ThreadProbe threadProbe, (string, Func<Task>) caseToExecute)
        {
            threadProbe.WriteLineThreadID($"Await start: {caseToExecute.Item1}");
            await caseToExecute.Item2();
            threadProbe.WriteLineThreadID($"Await end: {caseToExecute.Item1}");
            await Task.Delay(1000);
            threadProbe.WriteLineThreadID($"Delay end: {caseToExecute.Item1}");
            Console.WriteLine();
        }

        static async Task ExecuteCaseWithConfigureAwait(
            ThreadProbe threadProbe, (string, Func<Task>) caseToExecute,
            bool configureAwaitForExecuting, bool configureAwaitForWaiting
        )
        {
            threadProbe.WriteLineThreadID($"Await start: {caseToExecute.Item1}");
            await caseToExecute.Item2().ConfigureAwait(configureAwaitForExecuting);
            threadProbe.WriteLineThreadID($"Await end: {caseToExecute.Item1}");
            await Task.Delay(1000).ConfigureAwait(configureAwaitForWaiting);
            threadProbe.WriteLineThreadID($"Delay end: {caseToExecute.Item1}");
            Console.WriteLine();
        }

        static async Task ExecuteCaseWithEmptyAwait(ThreadProbe threadProbe, (string, Func<Task>) caseToExecute)
        {
            await Task.CompletedTask.ConfigureAwait(false);
            threadProbe.WriteLineThreadID($"Await start: {caseToExecute.Item1}");
            await caseToExecute.Item2();
            threadProbe.WriteLineThreadID($"Await end: {caseToExecute.Item1}");
            await Task.Delay(1000);
            threadProbe.WriteLineThreadID($"Delay end: {caseToExecute.Item1}");
            Console.WriteLine();
        }

        static async Task ExecuteCaseWithEmptyAwait2(ThreadProbe threadProbe, (string, Func<Task>) caseToExecute)
        {
            static async Task YieldOnlyAsync()
            {
                await Task.Yield();
            }

            threadProbe.WriteLineThreadID($"before YieldOnlyAsync: {caseToExecute.Item1}");
            await YieldOnlyAsync().ConfigureAwait(false);
            threadProbe.WriteLineThreadID($"Await start: {caseToExecute.Item1}");
            await caseToExecute.Item2();
            threadProbe.WriteLineThreadID($"Await end: {caseToExecute.Item1}");
            await Task.Delay(1000);
            threadProbe.WriteLineThreadID($"Delay end: {caseToExecute.Item1}");
            Console.WriteLine();
        }

        static async Task DummyMethod(ThreadProbe threadProbe, string label)
        {
            threadProbe.WriteLineThreadID($"{label} - before await()", 2);
            await Task.Delay(200);
            threadProbe.WriteLineThreadID($"{label} - after await()", 2);
        }

        static (string, Func<Task>) Case_AwaitAndReturnOriginalTask(ThreadProbe threadProbe)
        {
            var task = Task.Run(() => DummyMethod(threadProbe, "In Task.Run()"));
            task.ContinueWith(t => DummyMethod(threadProbe, "In ContinueWith()"));
            return ("Original Task Only (with ContinueWith)", () => task);
        }

        static (string, Func<Task>) Case_AwaitAndReturnContinueWithTask(ThreadProbe threadProbe)
        {
            var task = Task.Run(() => DummyMethod(threadProbe, "In Task.Run()"));
            task = task.ContinueWith(t => DummyMethod(threadProbe, "In ContinueWith()"));
            return ("ContinueWith returns Task<Task> (no Unwrap)", () => task);
        }

        static (string, Func<Task>) Case_AwaitAndReturnContinueWithUnwrappedTask(ThreadProbe threadProbe)
        {
            var task = Task.Run(() => DummyMethod(threadProbe, "In Task.Run()"));
            task = task.ContinueWith(t => DummyMethod(threadProbe, "In ContinueWith()")).Unwrap();
            return ("ContinueWith returns Task<Task> (Unwrapped)", () => task);
        }
    }
}
